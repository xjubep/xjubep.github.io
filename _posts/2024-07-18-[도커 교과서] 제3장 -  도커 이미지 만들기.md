---
title: "[도커 교과서] 제3장 - 도커 이미지 만들기"
excerpt: "[도커 교과서] 제3장 - 도커 이미지 만들기"

categories:
  - Docker Textbook
tags:
  - Docker
last_modified_at: 2024-07-18T22:00KST
---

## 1. 도커 허브에서 이미지 사용하기
도커 허브는 공개 이미지 레지스트리로, 많은 유용한 이미지를 제공합니다. 다음 명령어로 이미지를 다운로드할 수 있습니다:
```shell
docker image pull diamol/ch03-web-ping
```
이미지는 여러 개의 레이어로 구성되어 있으며, 각 레이어는 독립적으로 다운로드됩니다.

## 2. 컨테이너 실행과 환경 변수 설정
다운로드한 이미지로 컨테이너를 실행해봅시다:
```shell
docker container run -d --name web-ping diamol/ch03-web-ping
```
* `-d`: `--detach`의 축약형  
* `--name`: 컨테이너에 원하는 이름을 붙일 수 있음  

이 컨테이너는 3초마다 지정된 웹사이트에 ping을 보냅니다. 환경 변수를 통해 동작을 수정할 수 있습니다:
```shell
docker rm -f web-ping
docker container run --env TARGET=google.com diamol/ch03-web-ping
```

## 3. Dockerfile로 이미지 만들기
Dockerfile은 이미지 생성 과정을 스크립트로 작성한 것입니다. 다음은 간단한 Dockerfile 예시입니다:
```dockerfile
FROM diamol/node

ENV TARGET="blog.sixeyed.com"
ENV METHOD="HEAD"
ENV INTERVAL="3000"

WORKDIR /web-ping
COPY app.js .

CMD ["node", "/web-ping/app.js"]
```
Dockerfile의 각 인스트럭션은 이미지에 새로운 레이어를 추가합니다. 주요 인스트럭션들의 역할을 자세히 살펴보겠습니다:

1. **FROM**
   - 모든 Dockerfile은 FROM 인스트럭션으로 시작합니다.
   - 기존 이미지를 새 이미지의 기반으로 사용합니다.
   - 예: `FROM diamol/node`는 Node.js가 설치된 이미지를 기반으로 시작합니다.

2. **ENV**
   - 환경 변수를 설정합니다.
   - 컨테이너 실행 시 사용될 기본값을 지정할 수 있습니다.
   - 예: `ENV TARGET="blog.sixeyed.com"`

3. **WORKDIR**
   - 컨테이너 이미지 파일 시스템에 디렉터리를 생성합니다.
   - 해당 디렉터리를 이후 명령어들이 실행될 작업 디렉터리로 지정합니다.
   - 예: `WORKDIR /web-ping`

4. **COPY**
   - 로컬 파일 시스템의 파일이나 디렉터리를 컨테이너 이미지로 복사합니다.
   - 형식: `COPY [원본경로] [복사경로]`
   - 예: `COPY app.js .`

5. **CMD**
   - 컨테이너가 시작될 때 실행할 명령을 지정합니다.
   - Dockerfile당 하나의 CMD 인스트럭션만 유효합니다.
   - 예: `CMD ["node", "/web-ping/app.js"]`

주의: 인스트럭션은 대소문자를 구분하지 않지만, 가독성을 위해 대문자로 작성하는 것이 관례입니다.

## 4. 이미지 빌드하기
Dockerfile로 이미지를 빌드하는 명령어는 다음과 같습니다:
```shell
docker image build --tag web-ping .
```
1. `docker image build:` Docker 이미지를 생성하는 기본 명령어입니다.
2. `--tag web-ping`:
   * `--tag` (또는 `-t`) 옵션은 생성될 이미지의 이름을 지정합니다.
   * 여기서는 이미지 이름을 `web-ping`으로 설정했습니다.
   * 이 옵션을 생략하면 이미지가 임의의 ID로만 식별되므로, 관리를 위해 항상 태그를 지정하는 것이 좋습니다.
3. `.` (마지막의 점):
   * 이는 빌드 컨텍스트(build context)를 지정합니다.
   * 컨텍스트는 Dockerfile이 위치한 디렉터리와 이미지에 포함될 파일들이 있는 경로입니다.
   * `.`은 현재 작업 디렉터리를 의미합니다.
   * Docker 데몬은 이 경로 내의 모든 파일과 디렉터리를 빌드 프로세스에 사용할 수 있습니다.

주의사항:
* 빌드 컨텍스트에는 이미지 생성에 필요한 파일만 포함되어야 합니다. 불필요한 파일이 많으면 빌드 속도가 느려지고 이미지 크기가 커질 수 있습니다.
* `.dockerignore` 파일을 사용하여 빌드 컨텍스트에서 제외할 파일을 지정할 수 있습니다.

## 5. 이미지 레이어 이해하기
`docker image history` 명령으로 이미지의 레이어 구조를 볼 수 있습니다:
```shell
docker image history web-ping

IMAGE          CREATED         CREATED BY                                       SIZE      COMMENT
285a7ad169ea   8 minutes ago   CMD ["node" "/web-ping/app.js"]                  0B        buildkit.dockerfile.v0
<missing>      8 minutes ago   COPY app.js . # buildkit                         846B      buildkit.dockerfile.v0
<missing>      8 minutes ago   WORKDIR /web-ping                                0B        buildkit.dockerfile.v0
<missing>      8 minutes ago   ENV INTERVAL=3000                                0B        buildkit.dockerfile.v0
<missing>      8 minutes ago   ENV METHOD=HEAD                                  0B        buildkit.dockerfile.v0
<missing>      8 minutes ago   ENV TARGET=blog.sixeyed.com                      0B        buildkit.dockerfile.v0
<missing>      5 years ago     /bin/sh -c #(nop)  CMD ["node"]                  0B
<missing>      5 years ago     /bin/sh -c #(nop)  ENTRYPOINT ["docker-entry…   0B
<missing>      5 years ago     /bin/sh -c #(nop) COPY file:238737301d473041…   116B
<missing>      5 years ago     /bin/sh -c apk add --no-cache --virtual .bui…   5.1MB
<missing>      5 years ago     /bin/sh -c #(nop)  ENV YARN_VERSION=1.16.0       0B
<missing>      5 years ago     /bin/sh -c addgroup -g 1000 node     && addu…   64.7MB
<missing>      5 years ago     /bin/sh -c #(nop)  ENV NODE_VERSION=10.16.0      0B
<missing>      5 years ago     /bin/sh -c #(nop)  CMD ["/bin/sh"]               0B
<missing>      5 years ago     /bin/sh -c #(nop) ADD file:a86aea1f3a7d68f6a…   5.53MB
````
### 이미지 레이어의 특성
1. **공유와 재사용**: 이미지 레이어는 여러 이미지와 컨테이너에서 공유됩니다.
2. **읽기 전용**: 한번 생성된 레이어는 변경할 수 없습니다.
3. **1:1 관계**: 각 Dockerfile 인스트럭션은 하나의 이미지 레이어를 생성합니다.

### 이미지 구조의 이해
- Docker 이미지는 여러 레이어가 쌓인 논리적 객체입니다.
- 각 레이어는 Docker 엔진의 캐시에 물리적 파일로 저장됩니다.
- 예: 여러 Node.js 애플리케이션 컨테이너는 동일한 Node.js 런타임 레이어를 공유합니다.

### 기반 이미지와 레이어 상속
- 새로운 이미지는 기존 이미지를 기반으로 만들어집니다 (Dockerfile의 `FROM` 인스트럭션).
- 예: `web-ping` 이미지는 `diamol/node` 이미지의 모든 레이어를 상속받고, 그 위에 새로운 레이어(예: `app.js`)를 추가합니다.

### 이미지 크기와 실제 디스크 사용량
```shell
docker image ls

REPOSITORY                     TAG       IMAGE ID       CREATED          SIZE
web-ping                       latest    285a7ad169ea   12 minutes ago   75.3MB
busybox                        latest    65ad0d468eb1   14 months ago    4.26MB
diamol/ch02-hello-diamol-web   latest    3a29d4fe4767   3 years ago      55.5MB
diamol/base                    latest    9fc3f74c8b53   3 years ago      7.15MB
diamol/ch03-web-ping           latest    c748a03c9314   3 years ago      75.3MB
```
주의할 점:
* 이 명령어가 보여주는 크기는 각 이미지의 논리적 크기입니다.
* 실제 디스크 사용량은 이보다 훨씬 적을 수 있습니다. 왜냐하면 여러 이미지가 레이어를 공유하기 때문입니다.

실제 디스크 사용량을 확인하려면 다음 명령어를 사용하세요:
```shell
docker system df
```

### 레이어의 불변성(Immutability)
이미지 레이어가 여러 이미지에서 공유되기 때문에, Docker는 이미지 레이어를 읽기 전용으로 만듭니다. 이는 다음과 같은 이점을 제공합니다:
1. 데이터 일관성 유지
2. 이미지 간 충돌 방지
3. 효율적인 저장소 사용

이러한 레이어 구조와 공유 메커니즘 덕분에 Docker는 효율적으로 저장 공간을 사용하며, 빠른 이미지 배포가 가능합니다.

## 6. Dockerfile 최적화
Dockerfile의 명령 순서는 빌드 성능에 중요한 영향을 미칩니다. 효율적인 캐시 사용을 위해 자주 변경되는 부분은 파일의 뒷부분에 배치해야 합니다.

### 캐시 메커니즘 이해하기
- 도커는 빌드 시 각 인스트럭션의 결과가 이전 빌드와 동일한지 확인합니다.
- 일치하는 경우, 이전에 캐시된 레이어를 재사용합니다.
- 이 과정에서 도커는 해시값을 사용하여 캐시 일치 여부를 판단합니다.

### 해시값 계산 방식
- 해시값은 Dockerfile 스크립트의 인스트럭션과 복사되는 파일 내용을 기반으로 계산됩니다.
- 기존 이미지 레이어에 일치하는 해시값이 없으면 캐시 미스가 발생하고 해당 인스트럭션이 실행됩니다.
- 한 인스트럭션이 실행되면, 그 이후의 모든 인스트럭션도 수정 여부와 관계없이 실행됩니다.

### 최적화 전략
1. 잘 변경되지 않는 인스트럭션을 Dockerfile 앞부분에 배치합니다.
2. 자주 수정되는 인스트럭션은 뒷부분에 위치시킵니다.

이러한 최적화 방법은 이미지 빌드 및 공유 과정에서 다음과 같은 이점을 제공합니다:
- 빌드 시간 단축
- 디스크 용량 절약
- 네트워크 대역폭 효율적 사용

## 7. 수동으로 이미지 만들기
때로는 Dockerfile 없이 수동으로 이미지를 만들어야 할 때가 있습니다. 다음은 그 예시입니다:
```shell
docker container run -it --name ch03lab diamol/ch03-lab
echo Elton >> ch03.txt
exit
docker container commit ch03lab ch03-lab-soln
docker container run ch03-lab-soln cat ch03.txt
```
