---
title: "[도커 교과서] 제6장 - 도커 볼륨을 이용한 퍼시스턴트 스토리지"
excerpt: "[도커 교과서] 제6장 - 도커 볼륨을 이용한 퍼시스턴트 스토리지"

categories:
  - Docker Textbook
tags:
  - Docker
last_modified_at: 2024-07-23T22:00KST
---
## 1. 컨테이너와 데이터 지속성의 문제
컨테이너는 무상태 애플리케이션에 최적화된 환경을 제공합니다. 사용량 증가에 따라 컨테이너 수를 늘리기만 하면 모든 요청을 동일하게 처리할 수 있으며, 롤링 업데이트를 통해 서비스 중단 없이 업데이트도 가능합니다.

하지만 현실적으로 모든 애플리케이션이 완전히 무상태일 수는 없습니다. 지속성이나 성능 향상을 위해 디스크를 사용하는 컴포넌트가 필요하며, 이러한 유상태 애플리케이션을 도커로 실행할 때는 여러 가지 고려사항이 있습니다.

### 컨테이너 속 데이터가 사라지는 이유
도커 컨테이너는 독립된 파일 시스템을 가지며, 이는 이미지 레이어와 컨테이너의 쓰기 가능 레이어로 구성됩니다. 컨테이너가 삭제되면 쓰기 가능 레이어도 함께 삭제되어 데이터가 손실됩니다.

예를 들어, 터미널을 열고 동일한 이미지로 두 개의 컨테이너를 실행해 보겠습니다. 이 이미지에 포함된 애플리케이션은 컨테이너 내 파일에 무작위 숫자를 씁니다:
```shell
docker container run --name rn1 diamol/ch06-random-number
docker container run --name rn2 diamol/ch06-random-number
```

`docker container cp` 명령을 사용하여 두 컨테이너에서 무작위 숫자가 기록된 텍스트 파일을 로컬로 복사하고 파일 내용을 확인할 수 있습니다:
```shell
docker container cp rn1:/random/number.txt number1.txt
docker container cp rn2:/random/number.txt number2.txt

cat number1.txt
31458

cat number2.txt
26142
```
이를 통해 컨테이너의 파일 시스템이 서로 독립적임을 알 수 있습니다.

기록 가능 레이어는 새 파일을 만드는 것뿐만 아니라 기존 이미지 레이어에 있는 파일을 수정하는 데도 사용됩니다. 
도커는 기록 중 복사(copy-on-write) 방법을 사용해 읽기 전용 레이어의 파일을 수정할 수 있습니다. 
이미지 레이어에 포함된 파일을 수정하려면, 먼저 도커가 이 파일을 기록 가능 레이어로 복사한 다음, 그 레이어에서 파일을 수정합니다.

## 2. 도커 볼륨을 사용하는 컨테이너 실행하기
도커 볼륨은 컨테이너와 독립적으로 존재하며, 컨테이너에 연결할 수 있는 별도의 저장 공간입니다. 볼륨을 사용하면 데이터가 컨테이너의 생애주기와 별개로 유지됩니다.

### 볼륨 사용하는 방법
1. Dockerfile에서 `VOLUME` 인스트럭션 사용
2. 수동으로 볼륨 생성하여 컨테이너에 연결

### 볼륨 사용 예시
#### Dockerfile에서 `VOLUME` 인스트럭션 사용
다음은 볼륨을 사용한 멀티 스테이지 빌드 Dockerfile의 일부입니다: (diamol/ch06-todo-list)
```dockerfile
FROM diamol/dotnet-aspnet
WORKDIR /app
ENTRYPOINT ["dotnet", "ToDoList.dll"]

VOLUME /data
COPY --from=builder /out/ .
```
이 이미지로 컨테이너를 실행하면 `/data` 디렉터리가 자동으로 생성되고, 해당 디렉터리의 내용은 볼륨에 영구적으로 저장됩니다.

#### 볼륨을 사용한 컨테이너 실행 및 확인
1. 컨테이너 실행:
    ```shell
    docker container run --name todo1 -d -p 8010:80 diamol/ch06-todo-list
    ```
2. 컨테이너가 사용하는 볼륨 확인:
    ```shell
    docker container inspect --format '{{.Mounts}}' todo1
    ```
   출력 예시:
    ```shell
    [{volume 70e7068bd2c2ecc4598a8b6f73e967586879d92d079a6cb25706b0df46a2b6c2 /var/lib/docker/volumes/70e7068bd2c2ecc4598a8b6f73e967586879d92d079a6cb25706b0df46a2b6c2/_data /data local  true }]
    ```
3. 볼륨 목록 확인:
    ```shell
    docker volume ls
    ```
    출력 예시:
    ```shell
    DRIVER    VOLUME NAME
    local     70e7068bd2c2ecc4598a8b6f73e967586879d92d079a6cb25706b0df46a2b6c2
    ```
   
### 컨테이너 간 볼륨 공유
`--volumes-from` 플래그를 사용하면 컨테이너 간에 볼륨을 공유할 수 있습니다`:
1. 새로운 컨테이너 실행하여 볼륨 생성:
    ```shell
    docker container run --name todo2 -d diamol/ch06-todo-list
    docker container exec todo2 ls /data
    ```
2. 다른 컨테이너에서 기존 볼륨 공유:
    ```shell
    docker container run -d --name t3 --volumes-from todo1 diamol/ch06-todo-list
    ```
3. 볼륨 내용 확인:
    ```shell
    docker container exec t3 ls /data
    ```
    출력 예시:
    ```shell
    todo-list.db
    ```

### 볼륨을 이용한 애플리케이션 업데이트
1. 데이터를 저장할 볼륨 생성:
    ```shell
    docker volume create todo-list
    ```
2. 볼륨을 연결해 버전 1 애플리케이션 실행:
    ```shell
    docker container run -d -p 8011:80 -v todo-list:$target --name todo-v1 diamol/ch06-todo-list
    ```
3. 애플리케이션에 데이터를 추가한 후 컨테이너 삭제:
    ```shell
    # http://localhost:8011 페이지에서 애플리케이션에 데이터를 몇 건 추가함
    docker container rm -f todo-v1
    ```
4. 같은 볼륨을 사용해 버전 2 애플리케이션 실행:
    ```shell
    docker container run -d -p 8011:80 -v todo-list:$target --name todo-v2 diamol/ch06-todo-list:v2
    ```

### `VOLUME` 인스트럭션과 `--volume` 플래그의 차이점
- `VOLUME` 인스트럭션: 이미지를 빌드할 때 사용되며, 컨테이너를 실행할 때마다 새로운 볼륨을 생성합니다. 볼륨 식별자를 기억해야 재사용할 수 있습니다.
- `--volume` 플래그: 컨테이너 실행 시 명시적으로 지정된 볼륨을 사용합니다. 이미지에 정의된 볼륨이 무시되며, 새로운 볼륨이 생성되지 않습니다.

이미지를 만드는 입장에서는 안전하게 `VOLUME` 인스트럭션을 포함시키는 것이 좋지만, 사용자는 명시적으로 이름을 지정한 볼륨을 사용하는 것이 데이터 유실을 방지할 수 있습니다.

## 3. 파일 시스템 마운트를 사용하는 컨테이너 실행하기
도커에서는 호스트 컴퓨터의 파일 시스템을 컨테이너에 직접 연결하는 바인드 마운트(bind mount) 기능을 제공합니다. 
바인드 마운트를 사용하면 호스트 컴퓨터의 특정 디렉터리를 컨테이너의 디렉터리에 연결할 수 있습니다.

### 바인드 마운트 사용 예시
1. 호스트 디렉터리 준비:  
  호스트 컴퓨터에서 사용할 디렉터리를 만듭니다.
    ```shell
    mkdir ./databases
    ```
2. 컨테이너 실행:  
바인드 마운트를 사용하여 컨테이너를 실행합니다. 여기서는 현재 디렉터리의 `databases` 폴더를 컨테이너의 `/data` 폴더로 연결합니다.
    ```shell
    source="$(pwd)/databases" && target="/data"
    
    docker container run --mount type=bind,source=$source,target=$target -d -p 8012:80 diamol/ch06-todo-list
    ```
3. 결과 확인:  
    컨테이너가 생성한 파일이 호스트 디렉터리에 있는지 확인합니다.
    ```shell
    curl http://localhost:8012
    
    ls ./databases
    # 출력 예시: todo-list.db
    ```

### 바인드 마운트의 특징
* **양방향 접근**: 컨테이너와 호스트 컴퓨터가 서로의 파일을 읽고 쓸 수 있습니다.
* **보안 고려**: 컨테이너는 일반적으로 최소 권한으로 실행되며, 바인드 마운트를 사용하면 호스트 파일 시스템에 접근하기 위한 권한 설정이 필요할 수 있습니다.
* **읽기 전용 설정**: 파일 쓰기 작업이 필요 없는 경우, 호스트 디렉터리를 읽기 전용으로 연결할 수 있습니다. 이는 호스트에서 작성한 설정 파일을 컨테이너에서 사용할 때 유용합니다.

### 읽기 전용 바인드 마운트 예시
to-do 애플리케이션은 `/app/config` 경로에서 추가 설정 파일을 로드합니다. 호스트 컴퓨터의 설정 파일을 컨테이너에서 사용하려면 다음과 같이 설정합니다:

1. 경로 설정:  
호스트 디렉터리와 컨테이너 디렉터리를 환경 변수로 정의합니다.
    ```shell
    cd ./ch06/exercieses/todo-list
    
    source="$(pwd)/config" && target="/app/config"
    ```
2. 컨테이너 실행:  
바인드 마운트를 읽기 전용으로 설정하여 컨테이너를 실행합니다.
    ```shell
    docker container run --name todo-configured -d -p 8013:80 --mount type=bind,source=$source,target=$target,readonly diamol/ch06-todo-list
    ```
3. 애플리케이션 확인:  
애플리케이션이 작동하는지 확인합니다.
    ```shell
    curl http://localhost:8013
    ```

4. 컨테이너 로그 확인:  
애플리케이션 로그를 확인하여 설정 파일이 제대로 로드되었는지 확인합니다.
    ```shell
    docker container logs todo-configured
    ```

이처럼 바인드 마운트를 사용하면 호스트 컴퓨터의 파일 시스템을 유연하게 활용할 수 있으며, 애플리케이션 설정이나 데이터 관리에 유용하게 사용할 수 있습니다.

## 4. 파일 시스템 마운트의 한계점
바인드 마운트와 볼륨을 효율적으로 사용하려면 각 방식의 사용 시나리오와 한계점을 잘 이해해야 합니다.

### 시나리오 1: 컨테이너에 이미 존재하는 디렉터리에 마운트하기
컨테이너의 파일 시스템에 이미 존재하는 디렉터리에 바인드 마운트를 할 경우, 마운트된 디렉터리가 기존 디렉터리를 완전히 대체합니다. 
즉, 이미지에 포함된 원래 파일은 사용 불가능해집니다.

**예제**  
1. 바인드 마운트를 사용하지 않고 컨테이너 실행:
    ```shell
    cd ./ch06/exercises/bind-mount
    
    source="$(pwd)/new" && target="/init"
    
    docker container run diamol/ch06-bind-mount
    ```
    출력 예시:
    ```shell
    abc.txt
    def.txt
    ```
2. 바인드 마운트를 사용하여 컨테이너 실행:
    ```shell
    docker container run --mount type=bind,source=$source,target=$target diamol/ch06-bind-mount
    ```
    출력 예시:
    ```shell
    123.txt
    456.txt
    ```
위 예제에서 알 수 있듯이, 마운트된 디렉터리가 기존 디렉터리를 덮어씁니다.

### 시나리오 2: 호스트의 파일을 컨테이너 디렉터리에 마운트하기
호스트 컴퓨터의 파일 하나를 컨테이너에 이미 존재하는 디렉터리에 마운트하면, 디렉터리의 파일이 합쳐져서 이미지에서 온 파일과 호스트에서 마운트된 파일이 모두 나타납니다. 
다만, 윈도우 컨테이너에서는 이 기능이 지원되지 않습니다.

### 시나리오 3: 분산 파일 시스템을 컨테이너에 바인드 마운트하기
분산 파일 시스템을 컨테이너에 바인드 마운트할 경우, 네트워크 상의 모든 컴퓨터에서 데이터에 접근할 수 있지만, 로컬 파일 시스템과는 다른 동작 방식을 가질 수 있습니다. 
예를 들어, SMB, Azure Files, AWS S3 같은 파일 시스템은 로컬 운영체제 파일 시스템과 다르게 동작할 수 있습니다.

분산 파일 시스템을 마운트하면 일반 파일 시스템처럼 보이지만, 일부 동작이 지원되지 않을 수 있습니다. 
예를 들어, 파일 잠금 기능이나 특정 파일 속성 등이 제대로 동작하지 않을 수 있습니다.



## 5. 컨테이너 파일 시스템은 어떻게 만들어지는가?
모든 컨테이너는 도커가 다양한 출처로부터 모아 만든 단일 가상 디스크로 구성된 파일 시스템을 가집니다. 
이를 유니언 파일 시스템 (Union File System)이라고 합니다.

### 유니언 파일 시스템이란?
유니언 파일 시스템은 물리적 위치가 서로 다른 파일과 디렉터리를 하나의 단일 디스크처럼 보여주는 시스템입니다. 컨테이너에서 실행되는 애플리케이션은 단일 디스크만을 인식하지만, 실제로는 여러 출처의 파일과 디렉터리가 합쳐져 있습니다.

### 파일 시스템의 구성 요소
컨테이너의 파일 시스템은 여러 요소로 구성됩니다:

* **이미지 레이어**: 컨테이너의 초기 파일 시스템을 구성합니다.
* **기록 가능 레이어**: 컨테이너 내에서 변경된 내용을 저장합니다. 단기 데이터 저장에 적합합니다.
* **볼륨 마운트**: 컨테이너와 도커 객체인 볼륨 간 데이터를 공유합니다.
* **바인드 마운트**: 호스트 컴퓨터의 파일 시스템을 컨테이너와 공유합니다.

### 파일 시스템 구성 시 고려 사항
* **기록 가능 레이어**: 데이터의 캐싱 등 단기 저장에 적합합니다. 비용이 비싼 계산이나 네트워크를 통해 저장해야 하는 데이터에 사용됩니다.
* **로컬 바인드 마운트**: 호스트 컴퓨터와 컨테이너 간 데이터 공유에 사용됩니다. 로컬 컴퓨터에서 컨테이너로 소스 코드를 전달할 때 유용하며, 수정한 내용이 즉시 컨테이너에 반영됩니다.
* **분산 바인드 마운트**: 네트워크 스토리지와 컨테이너 간 데이터 공유에 사용됩니다. 가용성이 높지만 로컬 디스크와 비교해 성능이나 기능 면에서 차이가 있을 수 있습니다. 읽기 전용으로 설정 파일을 전달하거나 공유 캐시로 활용할 수 있으며, 읽기 쓰기가 가능해 동일 네트워크 상의 모든 컨테이너나 컴퓨터와 데이터를 공유하는 데 적합합니다.
* **볼륨 마운트**: 애플리케이션이 데이터를 영구적으로 저장할 때 사용됩니다. 애플리케이션 업데이트 시 컨테이너를 교체해도 데이터는 유지됩니다.
* **이미지 레이어**: 컨테이너의 초기 파일 시스템을 구성하며, 후속 레이어와 이전 레이어의 내용이 충돌하면 후속 레이어의 내용이 적용됩니다.

## 6. 연습 문제
이 연습 문제에서는 to-do 애플리케이션을 컨테이너로 실행할 때 미리 등록된 할 일이 없는 상태로 시작하도록 설정하는 방법을 알아보겠습니다.

### 단계별 연습 문제 해결 방법
1. **모든 컨테이너 삭제하기**  
먼저, 현재 실행 중인 모든 컨테이너를 삭제합니다:
    ```shell
    docker container rm -f $(docker container ls -aq)
    ```
2. **현재 등록된 할 일 확인하기**  
`diamol/ch06-lab` 이미지를 사용해 컨테이너를 실행하고, 현재 등록된 할 일을 확인합니다:
    ```shell
    docker container run -d -p 8015:80 diamol/ch06-lab
    ```
    웹 브라우저에서 http://localhost:8015/list 를 열어 현재 등록된 할 일을 확인합니다.
3. **마운트를 추가해 컨테이너 실행하기**  
다음으로, 마운트를 추가해 컨테이너를 실행합니다. 이를 위해 볼륨과 바인드 마운트를 설정합니다:
    ```shell
    # 새로운 볼륨 생성
    docker volume create ch06-lab
    
    # 경로 설정
    configSource="$(pwd)/solution"
    configTarget="/app/config"
    dataTarget="/new-data"
    
    # 마운트를 추가해 컨테이너 실행
    docker container run -d -p 8016:80 --mount type=bind,source=$configSource,target=$configTarget,readonly --volume ch06-lab:$dataTarget diamol/ch06-lab
    ```
   웹 브라우저에서 http://localhost:8016/list 를 열어 미리 등록된 할 일이 없는 상태로 애플리케이션이 시작되었는지 확인합니다.
