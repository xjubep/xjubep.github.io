---
title: "[도커 교과서] 제4장 - 애플리케이션 소스 코드에서 도커 이미지까지"
excerpt: "[도커 교과서] 제4장 - 애플리케이션 소스 코드에서 도커 이미지까지"

categories:
  - Docker Textbook
tags:
  - Docker
last_modified_at: 2024-07-19T22:00KST
---

## 1. Dockerfile과 빌드 서버의 필요성
소프트웨어 프로젝트를 빌드할 때 개발 팀원 모두가 동일한 도구와 버전을 사용해야 합니다. 
이는 빌드 서버에도 적용되며, 링커, 컴파일러, 패키지 관리자, 런타임 등이 포함됩니다. 
하지만 이 과정에서 큰 유지 보수 오버헤드가 발생할 수 있습니다.  

Docker를 사용하면 이러한 문제를 해결할 수 있습니다:
1. 모든 빌드 도구를 포함하는 Dockerfile을 작성합니다.  
2. 이 Dockerfile로 이미지를 생성합니다.
3. 애플리케이션 패키징을 위한 Dockerfile에서 이 이미지를 사용해 소스 코드를 컴파일합니다.

이를 통해 멀티 스테이지 빌드를 구현할 수 있으며, 각 빌드 단계는 독립적으로 실행되면서도 이전 단계의 결과물을 활용할 수 있습니다.

멀티 스테이지 빌드가 적용된 Dockerfile 스크립트
```dockerfile
FROM diamol/base AS build-stage
RUN echo 'Building...' > /build.txt

FROM diamol/base AS test-stage
COPY --from=build-stage /build.txt /build.txt
RUN echo 'Testing...' > /build.txt

FROM diamol/base
COPY --from=test-stage /build.txt /build.txt
CMD cat /build.txt
```
* `RUN`: 빌드 중에 컨테이너 안에서 명령을 실행한 다음 그 결과를 이미지 레이어에 저장함, RUN에서 실행할 수 있는 명령에는 특별한 제한이 없지만 FROM 인스트럭션에서 지정한 이미지에서 실행할 수 있는 것이어야 함  

## 2. 자바 애플리케이션 빌드 예제
자바 스프링부트 애플리케이션을 빌드하고 실행하는 과정을 살펴보겠습니다. 이 예제는 메이븐(Maven)과 OpenJDK를 사용합니다.
컴파일이 필요한 언어라면 어떤 언어라도 적용할 수 있는 패턴을 익히는 것이 목적입니다.
```dockerfile
FROM diamol/maven AS builder

WORKDIR /usr/src/iotd
COPY pom.xml .
RUN mvn -B dependency:go-offline

COPY . .
RUN mvn package

# app
FROM diamol/openjdk

WORKDIR /app
COPY --from=builder /usr/src/iotd/target/iotd-service-0.1.0.jar .

EXPOSE 80
ENTRYPOINT ["java", "-jar", "/app/iotd-service-0.1.0.jar"]
```

### Builder 단계 분석
Builder 단계는 Java 애플리케이션을 빌드하는 핵심 과정입니다. 주요 단계는 다음과 같습니다:

1. 기반 이미지 선택: `diamol/maven` 이미지를 사용합니다. 이 이미지에는 Maven과 OpenJDK가 포함되어 있어 Java 애플리케이션 빌드에 필요한 모든 도구를 제공합니다.
2. 작업 환경 설정:
   - 작업 디렉터리를 생성합니다.
   - `pom.xml` 파일을 복사합니다. 이 파일에는 Maven이 수행할 빌드 절차가 정의되어 있습니다.
3. 의존성 다운로드:
   - `RUN mvn -B dependency:go-offline` 명령을 실행합니다.
   - 이 과정은 시간이 오래 걸리므로 별도의 단계로 분리하여 Docker 레이어 캐시를 활용합니다.
   - 새로운 의존성이 추가될 경우에만 이 단계가 다시 실행됩니다.
4. 소스 코드 복사: `COPY . .` 명령으로 나머지 소스 코드를 복사합니다.
5. 애플리케이션 빌드 및 패키징:
   - `mvn package` 명령을 실행합니다.
   - 이 명령은 Java 소스 코드를 컴파일하고 JAR 파일로 패키징합니다.

### 최종 애플리케이션 이미지 생성 단계
Builder 단계가 완료되면, 최종 애플리케이션 이미지를 생성하는 단계로 넘어갑니다:
1. 런타임 환경 설정:
   - 기반 이미지로 `diamol/openjdk`를 사용합니다. 이 이미지에는 Java 11 런타임만 포함되어 있고, Maven은 포함되지 않습니다.
2. 애플리케이션 파일 복사:
   - 새로운 작업 디렉터리를 생성합니다.
   - Builder 단계에서 생성된 JAR 파일을 복사합니다. 이 JAR 파일에는 모든 의존성과 컴파일된 애플리케이션이 포함되어 있습니다.
3. 네트워크 설정:
   - `EXPOSE 80` 명령으로 80번 포트를 외부에 공개합니다.
4. 실행 명령 설정:
   - `ENTRYPOINT` 명령을 사용하여 컨테이너 실행 시 자동으로 실행될 명령을 지정합니다. `ENTRYPOINT` 인스트럭션은 `CMD` 인스트럭션과 같은 기능을 합니다.

### Java 애플리케이션 빌드 및 실행
애플리케이션을 빌드하고 실행하는 과정은 다음과 같습니다:
1. 이미지 빌드:
    ```shell
    cd ch04/exercises/image-of-the-day
    docker image build -t image-of-the-day .
    ```
2. Docker 네트워크 생성:
    ```shell
    docker network create nat
    ```
    - `--network` 옵션을 사용하여 컨테이너를 특정 네트워크에 연결할 수 있습니다.
3. 컨테이너 실행:
    ```shell
    docker container run --name iotd -d -p 800:80 --network nat image-of-the-day
    ```
   - 80번 포트를 호스트의 800번 포트로 매핑합니다.
   - nat 네트워크에 컨테이너를 연결합니다.
4. 애플리케이션 테스트:
   - http://localhost:800/image 에 접속하면 NASA의 오늘의 천문 사진 정보를 JSON 형식으로 볼 수 있습니다.

### 주요 포인트
- 이식성: 소스 코드와 Dockerfile만 있으면 어디서든 애플리케이션을 빌드하고 실행할 수 있습니다.
- 최적화된 이미지: 최종 애플리케이션 이미지에는 빌드 도구가 포함되지 않아 이미지 크기가 최적화됩니다.
- 분리된 빌드 환경: 빌드 과정과 실행 환경이 분리되어 있어 보안성과 효율성이 향상됩니다.

이러한 접근 방식은 개발, 테스트, 배포 과정을 일관되고 효율적으로 만들어 줍니다.

## 3. Node.js 애플리케이션 빌드 예제
최근 기술 스택의 다양화로 인해 Docker를 이용한 다양한 빌드 방식을 이해하는 것이 중요해졌습니다. Node.js는 널리 사용되는 스크립트 언어로, Java와는 다른 빌드 과정을 가집니다. 이 빌드 패턴은 Python, PHP, Ruby 등 다른 스크립트 언어에도 적용할 수 있습니다.

```dockerfile
FROM diamol/node AS builder

WORKDIR /src
COPY src/package.json .
RUN npm install

# app
FROM diamol/node

EXPOSE 80
CMD ["node", "server.js"]

WORKDIR /app
COPY --from=builder /src/node_modules/ /app/node_modules/
COPY src/ .
```

### Java vs Node.js 빌드 과정 비교
**Java 애플리케이션**
- 컴파일 과정 필요
- 빌드 단계에서 소스 코드를 컴파일하여 JAR 파일 생성
- 최종 이미지에는 컴파일된 JAR 파일만 포함, 소스 코드는 제외

**Node.js 애플리케이션**
- 인터프리터 언어로 별도의 컴파일 과정 불필요
- 최종 이미지에 Node.js 런타임과 소스 코드 모두 포함
- 멀티 스테이지 빌드를 통해 의존성 모듈 로딩 최적화

### Node.js 애플리케이션 Docker 빌드 과정
1. 기반 이미지: `diamol/node` (Node.js 런타임과 npm 포함)
2. 빌더 단계:
   - `package.json` 파일 복사
   - `npm install` 실행하여 의존성 모듈 설치
3. 최종 단계:
   - HTTP 포트 공개 및 애플리케이션 시작 명령 지정
   - 작업 디렉터리 생성
   - 애플리케이션 소스 코드 및 의존성 모듈 복사

### 애플리케이션 빌드 및 실행
1. 이미지 빌드:
    ```shell
    cd ch04/exercises/access-log
    docker image build -t access-log .
    ```
2. 컨테이너 실행:
    ```shell
    docker container run --name accesslog -d -p 801:80 --network nat access-log
    ```
3. 애플리케이션 테스트:
   - http://localhost:801/stats 에 접속하여 로그 건수 확인

## 4. Go 애플리케이션 빌드 예제
### Go 언어 소개
Go는 현대적인 크로스 플랫폼 언어로, 네이티브 바이너리로 컴파일되는 특징을 가집니다. 이는 다음과 같은 장점을 제공합니다:

- 다양한 플랫폼(Windows, Linux, amd64, ARM 등)에서 실행 가능한 바이너리 생성
- 별도의 런타임 불필요
- 매우 작은 크기의 Docker 이미지 생성 가능

Go는 클라우드 네이티브 애플리케이션 개발에 특히 인기가 높으며, Docker 자체도 Go로 구현되었습니다.

### Go 애플리케이션의 멀티 스테이지 Docker 빌드
Go 애플리케이션의 Docker 빌드는 Java와 유사하지만 몇 가지 중요한 차이점이 있습니다. 다음은 Go 애플리케이션의 Dockerfile 예시입니다:
```dockerfile
FROM diamol/golang AS builder

COPY main.go .
RUN go build -o /server

# app
FROM diamol/base
ENV IMAGE_API_URL="http://iotd/image" \
    ACCESS_API_URL="http://accesslog/access-log"

CMD ["/web/server"]

WORKDIR /web
COPY index.html .
COPY --from=builder /server .
RUN chmod +x server
```
### 빌드 과정 설명
1. Builder 단계:
   - `diamol/golang` 이미지를 사용하여 Go 빌드 환경 설정
   - 소스 코드를 복사하고 바로 빌드 실행 (의존성 다운로드 단계 없음)
2. 애플리케이션 단계:
   - 최소한의 OS 레이어만 포함하는 `diamol/base` 이미지 사용
   - 환경 변수 설정
   - Builder 단계에서 생성된 바이너리와 필요한 파일들 복사
   - 실행 권한 부여

### Go 애플리케이션 빌드 및 실행
1. 이미지 빌드:
    ```shell
    cd ch04/exercises/image-gallery
    docker image build -t image-gallery .
    ```
2. 이미지 크기 비교:
    ```shell
    docker image ls -f reference=diamol/golang -f reference=image-gallery
    ```
    결과:
    ```
    REPOSITORY      TAG       IMAGE ID       CREATED         SIZE
    image-gallery   latest    d90cc18e593b   2 minutes ago   27.1MB
    diamol/golang   latest    119cb20c3f56   3 years ago     803MB
    ```
3. 컨테이너 실행:
    ```shell
    docker container run -d -p 802:80 --network nat image-gallery
    ```
4. 애플리케이션 테스트:
   - http://localhost:802 에서 NASA의 오늘의 천문 사진 확인 가능

### 주요 포인트
- Go 애플리케이션은 매우 작은 크기의 최종 이미지 생성 가능 (예: 25MB)
- 빌드 도구 이미지(800MB 이상)와 최종 애플리케이션 이미지 크기의 큰 차이
- 최종 이미지에는 실행에 필요한 바이너리만 포함, 별도의 런타임 불필요

이 예제는 Java로 구현된 API와 Node.js로 구현된 API를 사용하는 분산 애플리케이션의 일부로, 멀티 스테이지 빌드를 통해 프로젝트의 이식성을 크게 향상시킬 수 있습니다.

## 5. 멀티 스테이지 Dockerfile의 이점
### 1. 빌드 환경의 표준화  
- **일관된 도구 사용**: 모든 개발자와 빌드 서버가 동일한 버전의 도구를 사용합니다.
- **환경 독립성**: 로컬 컴퓨터의 운영체제나 설치된 도구에 관계없이 동일한 빌드 결과를 얻을 수 있습니다.
- **버전 충돌 방지**: 개발자 간 도구 버전 차이로 인한 빌드 실패를 예방할 수 있습니다.  

**실무 적용 효과**:  
- 신규 개발자의 온보딩 시간 단축
- 빌드 서버 관리 부담 감소
- 일관된 빌드 결과로 인한 신뢰성 향상

### 2. 빌드 성능 최적화  
- **단계별 캐싱**: 각 빌드 단계는 독립적인 캐시를 가집니다.
- **효율적인 캐시 재사용**: 변경되지 않은 단계는 이전 빌드의 캐시를 재사용합니다.
- **빌드 시간 단축**: 최적화된 Dockerfile을 사용하면 대부분의 빌드 단계에서 시간을 크게 절약할 수 있습니다.  

**성능 최적화 팁**:
- Dockerfile을 신중하게 구성하여 자주 변경되는 부분과 그렇지 않은 부분을 분리합니다.
- 의존성 설치 단계를 별도로 분리하여 소스 코드 변경 시에도 의존성 캐시를 재사용할 수 있게 합니다.

### 3. 최종 이미지 최적화
- **불필요한 도구 제거**: 빌드에 필요했지만 실행에는 불필요한 도구들을 최종 이미지에서 제외할 수 있습니다.
- **이미지 크기 감소**: 작은 크기의 이미지는 더 빠른 배포와 시작 시간을 제공합니다.
- **보안성 향상**: 필요한 구성 요소만 포함함으로써 잠재적인 취약점을 줄일 수 있습니다.  

**최적화 전략**:
- 최소한의 베이스 이미지 사용 (예: Alpine Linux 기반 이미지)
- 필요한 실행 파일과 라이브러리만 최종 단계로 복사
- 불필요한 데이터나 중간 빌드 결과물 제거

멀티 스테이지 Dockerfile 스크립트를 효과적으로 활용하면 개발 프로세스를 표준화하고, 빌드 성능을 향상시키며, 최종 산출물의 품질과 보안성을 높일 수 있습니다. 이는 현대적인 컨테이너 기반 개발 및 배포 환경에서 큰 경쟁력이 될 수 있습니다.
