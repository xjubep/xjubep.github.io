
---
title: "[도커 교과서] 제5장 - 도커 허브 등 레지스트리에 이미지 공유하기"
excerpt: "[도커 교과서] 제5장 - 도커 허브 등 레지스트리에 이미지 공유하기"

categories:
  - Docker Textbook
tags:
  - Docker
last_modified_at: 2024-07-22T22:00KST
---
이전까진 도커의 기본적인 워크플로 중 빌드와 실행에 대해 배웠음  
이번에는 공유에 대해 배움  
공유란 로컬 컴퓨터에서 빌드한 이미지를 다른 사람이 사용하는 것  

## 1. 레지스트리, 리포지터리, 이미지 태그 이해하기
도커 이미지는 레지스트리라는 서버에 저장됩니다. 가장 유명한 레지스트리는 도커 허브입니다. 이미지 이름은 다음과 같은 구조를 가집니다:
```shell
docker.io/diamol/golang:latest
```
- `docker.io`: 레지스트리 도메인 (기본값은 도커 허브)
- `diamol`: 계정 이름
- `golang`: 리포지터리 이름
- `latest`: 이미지 태그 (기본값은 `latest`)

## 2. 도커 허브에 이미지 푸시하기
### 1. 도커 허브 계정 생성
### 2. 도커 허브 계정 환경 변수 설정:
```shell
# 윈도 환경의 파워셸
$dockerId="도커허브계정이름"

# 리눅스 또는 macOS 환경의 배시 셸
export dockerId="도커허브계정이름"
```
### 3. 터미널에서 도커 허브 로그인:
```shell
docker login --username $dockerId
```
### 3. 이미지에 새 태그 부여:
```shell
docker image tag image-gallery $dockerId/image-gallery:v1
```
`image-gallery` 이미지의 이미지 참조 목록 확인
```shell
docker image ls --filter reference=image-gallery --filter reference='*/image-gallery'

REPOSITORY             TAG       IMAGE ID       CREATED      SIZE
image-gallery          latest    d90cc18e593b   2 days ago   27.1MB
xjubep/image-gallery   v1        d90cc18e593b   2 days ago   27.1MB
```
### 4. 이미지 도커허브에 푸시:
```shell
docker image push $dockerId/image-gallery:v1
```

## 3. 개인 도커 레지스트리 운영하기
로컬 네트워크에 전용 레지스트리를 운영하면 다음과 같은 장점이 있습니다:

- 인터넷 사용량 감소
- 전송 시간 단축
- 데이터 보안 강화

### 1. 레지스트리 컨테이너 실행
```shell
# --restart 플래그를 부여하면 도커를 재시작했을 때, 해당 컨테이너도 자동으로 재시작
docker container run -d -p 5000:5000 --restart always diamol/registry
```
### 2. hosts 파일에 도메인 추가
```shell
# 윈도 환경의 파워셸
Add-Content -Value "127.0.0.1 registry.local" -Path /windows/system32/drivers/etc/hosts

# 리눅스 또는 macOS 환경의 배시 셸
echo $'\n127.0.0.1 registry.local' | sudo tee -a /etc/hosts
```
### 3. 비보안(HTTP) 레지스트리 허용 설정
이미지 레이어의 저장 경로, 도커 API가 주시하는 포트 번호, 허용된 비보안 레지스트리 목록 등 도커 엔진의 모든 설정은 `daemon.json` 이라는 JSON 포맷으로 된 설정 파일에서 관리됩니다.  
이 파일은 다음 위치에 있습니다:

- 윈도: `C:\Program Data\docker\config`
- 리눅스: `/etc/docker`
`daemon.json` 파일을 열어 다음 내용을 추가하세요:
```json
{
"insecure-registries": ["registry.local:5000"]
}
```
설정 변경 후 도커 엔진을 재시작해야 합니다:
- 윈도 서버: `Restart-Service Docker`
- 리눅스 서버: `service docker restart`
 
변경된 설정을 확인하려면 다음 명령어를 실행하세요:
```shell
docker info
```
출력에서 다음 내용을 확인할 수 있습니다:
```shell
Insecure Registries:
 registry.local:5000
```

### 4. 로컬 레지스트리에 이미지 푸시하기  
이제 태그를 부여한 이미지를 로컬 레지스트리에 푸시할 수 있습니다:
```shell
docker image tag image-gallery registry.local:5000/gallery/ui:v1
docker image push registry.local:5000/gallery/ui:v1
```

## 4. 이미지 태그를 효율적으로 사용하기
도커 이미지 태그는 버전 관리에 중요한 역할을 합니다. 일반적으로 소프트웨어 버전 관리에 사용되는 [major].[minor].[patch] 형식을 따르는 것이 좋습니다.  

**버전 번호의 의미**
- **Patch**: 버그 수정만 포함. 기능은 이전 버전과 동일
- **Minor**: 새로운 기능 추가. 기존 기능은 유지
- **Major**: 주요 변경사항 포함. 이전 버전과 호환되지 않을 수 있음

**태그 사용 예시**
Go 애플리케이션에 버전 태그를 부여하는 방법:
```shell
docker image tag image-gallery registry.local:5000/gallery/ui:latest
docker image tag image-gallery registry.local:5000/gallery/ui:2
docker image tag image-gallery registry.local:5000/gallery/ui:2.1
docker image tag image-gallery registry.local:5000/gallery/ui:2.1.106
```

**버전 변경 예시**  

| `:latest`  | `:latest`  | `:latest` | `:latest` |
|----------|----------|---------|---------|
| `:2`       | `:2`       | `:2`      | `:3`      |
| `:2.1`     | `:2.1`     | `:2.2`    | `:3.0`    |
| `:2.1.106` | `:2.1.114` | `:2.2.11` | `:3.0.42` |

**태그 사용 전략**  
- 특정 패치 버전 (예: `2.1.106`)을 사용하면 항상 동일한 버전 보장
- 패치 업데이트를 자동으로 받으려면 마이너 버전 태그 (예: `2.1`) 사용
- 마이너 업데이트까지 자동으로 받으려면 메이저 버전 태그 (예: `2`) 사용

이렇게 태그를 효율적으로 사용하면 애플리케이션의 안정성과 업데이트 관리를 더욱 쉽게 할 수 있습니다.

## 5. 공식 이미지에서 골든 이미지로 전환하기
도커 허브의 이미지 신뢰성 문제를 해결하기 위해 도커는 두 가지 제도를 운영합니다:  
**1. 검증된 퍼블리셔(Verified Publisher)**  
* 신뢰할 수 있는 대기업(예: 마이크로소프트, 오라클, IBM)이 제공
* 취약점 탐지 등 엄격한 승인 절차를 거침
* 도커와 퍼블리셔의 공식 지원 제공
* 최신 소프트웨어 버전을 안전하게 사용하고 싶을 때 추천


**2. 공식 이미지(Official Image)**  
* 주로 오픈 소스 소프트웨어 대상
* 프로젝트 개발 팀과 도커가 공동 관리
* 정기적인 취약점 검사와 업데이트
* 최적화된 Dockerfile 스크립트 제공
* 모든 내용이 공개되어 있어 투명성 확보

**골든 이미지 (Golden Image)**  
공식 이미지를 기반으로 하되, 조직의 특정 요구사항을 반영한 이미지입니다.  
* 공식 이미지에 인증서, 환경 설정 등을 추가
* 기업 내부 리포지터리에서 관리
* 신뢰성과 커스터마이징의 장점을 결합

예시:
* 공식 이미지: `openjdk:11.0.3`
* 골든 이미지: `golden/openjdk:1907`
* 프로젝트 이미지: `project/java-app`

**골든 이미지 생성 예시 (닷넷 코어)**

```shell
# SDK 이미지 빌드
cd ch05/exercises/dotnet-sdk
docker image build -t golden/dotnetcore-sdk:3.0 .

# Runtime 이미지 빌드
cd ../aspnet-runtime
docker image build -t golden/aspnet-core:3.0 .
```
SDK 골든 이미지 Dockerfile:
```dockerfile
FROM mcr.microsoft.com/dotnet/core/sdk:3.0.100

LABEL framework="dotnet"
LABEL version="3.0"
LABEL description=".NET Core 3.0 SDK"
LABEL owner="golden-images@sixeyed.com"

WORKDIR src
COPY global.json .
```

Runtime 골든 이미지 Dockerfile:
```dockerfile
FROM mcr.microsoft.com/dotnet/core/aspnet:3.0

LABEL framework="dotnet"
LABEL version="3.0"
LABEL description=".NET Core 3.0 Runtime"
LABEL owner="golden-images@sixeyed.com"

EXPOSE 80
```

골든 이미지를 사용한 멀티 스테이지 빌드 예시:
```dockerfile
FROM golden/dotnetcore-sdk:3.0 AS builder
COPY . .
RUN dotnet publish -o /out/app app.csproj

FROM golden/aspnet-core:3.0
COPY --from=builder /out /app
CMD ["dotnet", "/app/app.dll"]
```

**골든 이미지의 장점**

* 업데이트 주기를 조직의 needs에 맞게 조절 가능
* CI/CD 파이프라인에서 골든 이미지 사용을 강제할 수 있음
* 조직 특화 설정을 일관되게 적용 가능

골든 이미지는 공식 이미지의 신뢰성과 조직 맞춤 설정의 유연성을 동시에 제공하는 효과적인 방법입니다.
